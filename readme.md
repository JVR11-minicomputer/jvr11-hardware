# JVR11 Homebrew Minicomputer - Hardware
This repository contains all schematics, PCB designs and PLD design sources of the JVR11, a homebrew minicomputer built around the DEC DCJ11 microprocessor. The computer will be built in multiple phases, each described in detail below.

All schematics and PCBs are designed in KiCad. All designs targeting SPLDs like the GAL16V8 and 22V10 are designed in WinCUPL, except the old sources, which were designed in GALASM. These will be replaced later. The CPLDs I used are all part of the ATF1504AS series, which can be used as an alternative to the MAX7000 series. All RTL is written in SystemVerilog and compiled using an older version of Quartus, targeting the MAX7000 series. The outputs were then converted to JEDEC using Atmel's POF2JED tool.

## Goals
### Phase 1: ODT Console    (FINISHED)

This is the very first stage of the project. My goal is to build a minimal but functional system capable of running a simple program. All the computer needs is a UART used to interact with the built-in ODT console and a little bit of SRAM to peek/poke into. This UART interface is built around the (Harris) 6402. Programs can be entered manually into memory and executed using this console, so no ROM is required. The ODT console itself is implemented in the processor's microcode.

The computer also needs to be able to load some startup configuration from a special register during its power-up sequence. A GAL22V10 is used as an interface to this register, I call it the "GP-interface". "GP" refers to the general-purpose cycles, which is a special kind of bus transaction that plays a big role during the power-up sequence. In addition, this interface is also responsible for generating the bus-reset signal and driving some status LEDs indicating whether the processor is in its "ODT mode" and also the results of the three microdiagnostics tests. All of this will be moved to the front panel later.

Known problems that still need to be fixed:
- The reset pin of the UART seems to be very sensitive to noise. When it is driven by the bus-reset signal, it starts acting weird. I believe this can be related to the fact that everything is built on breadboards, which is not ideal. As a temporary workaround, I tied the reset pin to ground.

### Phase 2: Bus Controller Upgrade     (IN PROGRESS)
In the previous phase, the computer used a single GAL16V8 to generate the bus access strobes (read enable, write enable etc). While being sufficient for a minimal functional system, it lacks a lot of functionality that we'll depend on later. This phase is all about implementing this missing functionality. First of all, it lacks the possibility to extend the cycle by inserting wait states. This will be required when interacting with slower IO devices and also in case of a cache miss. Second, since I'm planning to add DMA in the future, we need to support bus arbitration in order to be able to request mastership over the bus. Finally, we did not care about abort conditions. The internal MMU is capable of generating internal error conditions in which the remainder of the current cycle must be ignored and the access strobes are to be inhibited. An abort can also be generated by external hardware, but under specific conditions. In our case the system may report an error when referring to non-existent memory/IO or when writing to a read-only location or reading from a write-only location.

### Phase 3: Memory Subsystem     (IN PROGRESS)
Every computer needs random-access memory. The J11 is capable of addressing 4MiB of physical memory of which the top 8K is reserved for memory-mapped IO. The remainder will be filled by RAM and a bit of ROM. Filling almost 4MiB with SRAM is practically possible with modern chips, but that would violate one of my most important constraints: keeping it as historically correct as possible. Therefore I will be using asynchronous DRAM. 

Dynamic memory has two serious disadvantages: it's slow and needs periodic refreshes, or the data you stored will be lost. When it comes to refreshing the memory at regular intervals, I want to keep it as transparent to the CPU as possible by implementing a dedicated controller that runs on its own clock domain. When it comes down to the DRAM speeds, a single layer of write-back direct-mapped cache will be added which will act as a faster buffer between the fast system and its slow memory. The cache will offer 32KiB of SRAM to buffer both instructions and data (still unified), organized as 8K 32-bit cache blocks.

### Phase 4: IO Bridge  (NOT STARTED)
Depending on the exact version, the J11 can run at a maximum clock speed of either 15MHz or 18MHz. That is way too fast to interface with slower IO controller chips directly. The simplest solution would be to rely on the wait state mechanism implemented by the bus controller to relax the speeds, but for write cycles that will cause stalls that could be avoided. Instead, a bridge can be added which buffers the write transactions targeting the slower IO devices behind it. The CPU can "deposit" the write data into this bridge at its full operating speed and resume execution while the IO bridge "proxies" that transaction on the slower bus. Unfortunately, read transfers cannot be buffered.

### Phase 5: Interrupts & DMA  (NOT STARTED)
The J11 supports vectored interrupts on multiple priority levels. A dedicated interrupt controller will be required to provide the vector address to the processor during an interrupt acknowledge cycle. I want those vector addresses to be fully programmable.

For high-throughput IO devices DMA can be used to transfer data without the processor's involvement. I want to build a flexible DMA controller that is fully programmable, has multiple channels with internal prioritization, can handle both 8 or 16 bit word sizes, can handle memory-to-memory transfers and can handle chained/scatter-gather transfers. The latter is required since the J11's internal MMU can map non-consecutive pages. Its design is inspired by the Motorola 68450 DMAC.

### Phase 6: Adding More IO  (NOT STARTED)
The most fundamental objective of this project is to build a minicomputer. While there is no real definition of what makes a computer a minicomputer, my interpretation of a minicomputer is a "big" computer that has multi-user capabilities and a lot of IO. From a hardware point of view, this is the moment where the homebrew computer turns into a proper minicomputer. With the IO bridge in place and interrupts and DMA being supported, it is finally time to start adding more and more IO devices to the system. I will add as much as I can, including: storage, timers, displays, sound, and more.

### Phase 7: VGA Subsystem  (NOT STARTED)

I always wanted to build my own VGA subsystem, so this is my chance. I got inspired by two unrelated video controllers: [James Sharman's VGA](https://youtube.com/playlist?list=PLFhc0MFC8MiD2QzxJKi_bHqwpGBZZpYCt&feature=shared) and the IBM PGA. James Sharman built a VGA controller completely from scratch, featuring advanced functionality such as scrolling, beam racing, tilemaps and more. The PGA on the other hand is a less-known video controller made by IBM that had a 8088 on board serving as a coprocessor. It could emulate a CGA, but more interestingly, it could be used to offload high-level commands. These two video controllers are completely different: on one hand we have complex functionality implemented in hardware and on the other we have software emulation. That raises one important question: Can we combine the best of both worlds? Can we build a VGA controller that implements complex functionality in hardware but also features a dedicated coprocessor that can offload things from the J11?

I don't have any concrete plans yet and I don't know how far I will take this, if I can even get to this point. But, I am sure about one thing: the 8088 is a great processor but if I were going to use a coprocessor I'd choose a less common processor. If possible, I want to keep it minicomputer-related. Or even better, DEC-related so both processors share some common history. That left me with one specific processor: the DEC DCT11. The J11 and the T11 both implement the PDP-11 instruction set, but other than that they do not have anything in common.
